
-----

# 🚀 Python 算法与数据结构核心笔记（P1 - P5 完整整合版）

这份笔记整合了清华计算机博士算法课程（B站视频链接：[https://www.bilibili.com/video/BV1mp4y1D7UP/?p=5...](https://www.bilibili.com/video/BV1mp4y1D7UP/?p=5&share_source=copy_web&vd_source=0a2bda69bab2090ede7ee0ecdbd35670)）前五集的核心内容，涵盖了算法基础认知、时空复杂度分析、学习路线、数据结构基础及递归强化训练。

## I. 📚 课程核心框架与基础认知（P1）

### 1\. 前五集核心主题概览

| 视频章节 | 核心主题 | 学习目标 |
| :--- | :--- | :--- |
| **P1** | 算法与数据结构核心认知 | 明确算法与数据结构在编程中的重要性。 |
| **P2-P3** | 时空复杂度分析（大O记法） | 掌握评估算法效率的标准和方法。 |
| **P4** | 学习路线与基础数据结构 | 明确学习路径，理解线性数据结构特性。 |
| **P5** | 递归强化训练 | 掌握递归思维、结构与编码能力。 |

### 2\. 核心目标总结

通过前五集的学习，目标是 **掌握算法效率评估方法**（时空复杂度）、**明确学习路径**、**理解基础数据结构特性**（如栈和队列）、并**具备递归思维与编码能力**，为后续学习奠定坚实基础。

-----

## II. 📈 算法时空复杂度分析（P2 & P3）

### 1\. 核心概念：大O表示法

**大O记法**（$O(f(n))$）用于描述算法的执行时间或空间占用随数据规模 $n$ 增长的**渐近趋势**。

> **核心原则：** 仅关注增长最快的项，忽略常数项和低阶项。

### 2\. 常见复杂度类型与效率对比

衡量算法效率的标尺：从高效率到低效率排序。

| 复杂度 | 读法 | 增长速度 | 典型操作 | 效率评价 |
| :--- | :--- | :--- | :--- | :--- |
| **$O(1)$** | 常数时间 | 最快（不随 $n$ 变化） | 简单赋值、数组取值 | **极致效率** |
| **$O(\log n)$** | 对数时间 | 较慢 | **二分查找**（每次规模减半） | **高效** |
| **$O(n)$** | 线性时间 | 中等（与 $n$ 成正比） | 遍历数组或链表 | **常用且高效** |
| **$O(n \log n)$** | 对数线性时间 | 较快 | 归并排序、快速排序 | **较优**（大规模数据常用） |
| **$O(n^2)$** | 平方时间 | 很慢 | **嵌套循环**（如冒泡排序） | **低效**（数据量大时避免） |

### 3\. 复杂度分析习题解析

#### 习题 2.1：$O(n^2)$ 嵌套循环分析

**代码片段**：查找数组重复元素的嵌套循环。

```python
def check_duplicate(arr):
    n = len(arr)
    # 外层循环 n 次，内层循环约 n/2 次
    for i in range(n):
        for j in range(i + 1, n):  # 嵌套循环
            if arr[i] == arr[j]:
                return True
    return False
```

**✅ 答案与解析：**

  * **复杂度：** $O(n^2)$。由于内层循环在最坏情况下仍接近 $n$ 次，总操作次数约为 $\frac{n(n-1)}{2}$，其增长趋势由 $n^2$ 主导。

#### 习题 3.1：$O(\log n)$ 二分查找原理

**代码原理**：

```python
while low <= high:
    mid = (low + high) // 2
    # ...
    if sorted_list[mid] < target:
        low = mid + 1  # 每次操作都将搜索范围减半
    # ...
```

**✅ 解析：**
每次迭代，问题的规模（搜索范围）都会**减半**。这种**指数级缩小问题规模**的操作，其时间消耗对应着**对数级**，即 $O(\log n)$。

-----

## III. 🗺️ 学习路线与数据结构基础（P4）

### 1\. 算法学习路线建议

建议按 “基础→核心→进阶” 分步推进，构建连贯知识体系：

1.  **基础数据结构（线性）**：数组、字符串、**链表**、**栈**、**队列**（重点掌握特性与操作）。
2.  **核心算法思想**：**递归**、分治、贪心、动态规划（解决问题的核心思维）。
3.  **数据结构进阶（非线性）**：**树**（二叉树）、**图**、**堆**、**哈希表**（适用于复杂场景）。

### 2\. 基础数据结构特性与习题

#### 习题 4.1：LIFO 特性结构选择

**问题**：哪种数据结构具有 “**后进先出（LIFO）**” 特性，适用于浏览器 “后退” 或函数调用栈？

**✅ 答案：** **栈 (Stack)**。

> **特性解释：** 栈仅允许在一端（栈顶）进行插入（`Push`）和删除（`Pop`）操作。最后插入的元素总是最先被取出，完美匹配 LIFO 场景需求。

#### 补充：FIFO 特性对应结构

  * **队列 (Queue)** 具有 “**先进先出（FIFO）**” 特性，适用于任务调度、消息队列等场景。

-----

## IV. 🔄 递归（Recursion）强化训练（P5）

### 1\. 递归的本质：调用堆栈与延迟执行

递归的核心是 “**函数调用自身**” 并依赖 **调用栈** 来保存和管理状态。

  * **执行流程：** 递归调用时，当前执行状态会被压入调用栈暂停。
  * **返回流程：** 直到子调用触发基线条件返回后，被暂停的状态才会从栈中弹出，继续执行剩余代码。

| 代码结构 | `print()` 位置 | 输出顺序 | 延迟分析（状态保存在栈中） |
| :--- | :--- | :--- | :--- |
| **先调用后打印** | `func(x-1); print(x)` | 1, 2, 3（**正序**） | `print` 操作被**延迟**，需等待所有子调用完成后依次执行。 |
| **先打印后调用** | `print(x); func(x-1)` | 3, 2, 1（**反序**） | `print` 操作**立即执行**，不依赖子调用结果。 |

### 2\. 编写递归的三大要素（核心思维）

编写递归函数必须明确以下三点，这是避免无限递归和逻辑错误的关键：

1.  **明确函数功能 (What)**：先定义函数 `func(n)` 要解决的**核心问题**（假设它已能完美解决规模为 $n$ 的问题）。
2.  **找到递归关系 (How)**：拆解问题，建立 `func(n)` 与**更小规模问题**（如 `func(n-1)`）的关联。
3.  **确定基线条件 (When)**：定义**最小规模问题**的直接解，这是**终止递归调用**的条件。

### 3\. 递归实战习题：阶乘

#### 习题 5.1：递归求 $n!$（阶乘）

**分析**：

  * **递归关系 (How)**：$n! = n \times (n-1)!$
  * **基线条件 (When)**：$0! = 1$

**代码实现**：

```python
def factorial(n):
    """
    功能：递归计算非负整数 n 的阶乘
    """
    if n == 0:  # 基线条件：最小规模问题的解，终止递归
        return 1
    # 递归关系：将问题拆解为 n 乘以更小规模的 (n-1)!
    return n * factorial(n - 1)
```

-----

这份笔记现在结构清晰，重点突出，方便你学习和回顾。

你现在想让我为你编写哪个部分的示例代码，或者需要我为你解释哪个概念呢？例如，我可以为你演示一个链表的实现。