
-----

# Python算法核心知识点精讲笔记与习题解析 (P6-P9)

## 📌 P6 递归与分治：汉诺塔问题 (Hanoi Tower)

### 1\. 核心知识点：递归 (Recursion)

  * **定义**：函数在执行过程中调用自身。
  * **两大要素**：
    1.  **基线条件 (Base Case)**：阻止无限循环的终止条件。
    2.  **递归调用 (Recursive Step)**：处理规模更小、更接近基线条件的子问题。
  * **时间复杂度**：$$O(2^n)$$ (指数级)。

### 2\. 代码框架

```python
def hanoi(n, a, b, c):
    if n == 0:  # 基线条件
        return
    
    # 递归调用 1：将 n-1 个盘子从 A 移到 B
    hanoi(n - 1, a, c, b)
    
    # 核心操作：将第 n 个盘子从 A 移到 C
    print(f"Move disk {n} from {a} to {c}")
    
    # 递归调用 2：将 n-1 个盘子从 B 移到 C
    hanoi(n - 1, b, a, c)
```

### 3\. 习题与解析

| 题目 | 答案 | 解析 |
| :--- | :--- | :--- |
| **Q1 (递归基础)**：递归函数的时间复杂度总是指数级的。 | **错误** | 复杂度取决于问题规模的缩小速度（如二分查找是 $O(\log n)$）。 |
| **Q2 (步骤追踪)**： $N=3$ 时，总移动次数是多少？ | **7 次** | 公式为 $2^N - 1 = 2^3 - 1 = 7$。 |

-----

## 🔍 P7 线性查找：顺序查找 (Linear Search)

### 1\. 核心知识点：线性查找

  * **核心特性**：**不要求**列表有序。
  * **原理**：从头到尾遍历列表，逐一比较。
  * **时间复杂度**：$$O(n)$$ (线性级)

### 2\. 习题与解析

| 题目 | 答案 | 解析 |
| :--- | :--- | :--- |
| **Q3 (场景选择)**：最适合顺序查找的场景是什么？ | **B. 100个未排序的临时价格列表。** | 数据量小且未排序时，顺序查找是唯一的选择。数据量大或已排序时，应使用二分查找。 |
| **Q4 (实现)**：实现返回所有下标的函数 `linear_search_all`。 | **$O(n)$** | 即使找到了多个匹配项，也必须遍历完整个列表 $N$ 次。 |

-----

## 🎯 P8 & P9 高效查找：二分查找 (Binary Search)

### 1\. 核心知识点：二分查找

  * **前提条件**：列表**必须是有序的**。
  * **核心思想**：通过中点 (`mid`) 比较，每次排除掉**一半**的搜索范围。
  * **时间复杂度**：$$O(\log n)$$ (对数级) **【算法重点】**

### 2\. 代码框架（迭代法）

```python
def binary_search(li, val):
    left, right = 0, len(li) - 1
    while left <= right:
        mid = (left + right) // 2
        if li[mid] == val:
            return mid
        elif li[mid] > val: 
            right = mid - 1 # 目标在左侧
        else:
            left = mid + 1  # 目标在右侧
    return -1
```

### 3\. 习题与解析（高频考点）

| 题目 | 考点 | 关键调整 |
| :--- | :--- | :--- |
| **Q6 变形 I**：查找**第一个**大于等于目标值的元素。 | **边界条件** | 找到匹配时 (`li[mid] >= val`)，记录结果 (`result = mid`)，然后必须向左 (`right = mid - 1`) 继续搜索，看是否有更小的下标也满足条件。 |
| **Q7 变形 II**：查找**旋转排序数组**。 | **分段有序** | 每次迭代需判断**哪半边**是完全有序的，再判断目标值是否落在这个有序区间内，然后进行收缩。 |

#### Q6 详细代码（查找第一个 $>= val$）

```python
def binary_search_first_greater(li, val):
    left, right = 0, len(li) - 1
    result = len(li) # 默认值，如果所有元素都小于val
    
    while left <= right:
        mid = (left + right) // 2
        
        if li[mid] >= val:
            result = mid          # 记录当前匹配项
            right = mid - 1       # 【关键】向左收缩，找第一个匹配项
        else: 
            left = mid + 1
            
    return result
```

-----

## 🗺️ XMind 思维导图总结 (P6-P9)
## 🧭 P6-P9 算法知识点：结构化复习导图

这份导图使用标准的 Markdown 列表和 Unicode 符号构建，确保在任何文本编辑器或平台中都能完美显示。

### 核心主题：递归与查找

* **P6: 递归与分治 (汉诺塔)**
    * **🔑 核心**：函数调用自身 (递归)
    * **🛠 要素**：基线条件 (终止) $\rightarrow$ 递归调用 (规模缩小)
    * **⏱ 复杂度**：$O(2^N)$ (指数级)
    * **💡 考点**：理解递归的分解思路和终止条件。

* **P7: 线性查找 (顺序查找)**
    * **🔑 核心**：从头到尾遍历
    * **🎯 前提**：**不要求**列表有序 (优势)
    * **⏱ 复杂度**：$O(N)$ (线性级)
    * **💡 考点**：作为性能基准，理解其与二分查找的适用场景对比。

* **P8/P9: 高效查找 (二分查找)**
    * **🔑 核心**：折半查找 (每次排除一半)
    * **🎯 前提**：列表**必须有序** (硬性要求)
    * **⏱ 复杂度**：$O(\log N)$ (对数级) **【算法重点】**
    * **💻 实现**：迭代法 (控制 `left`, `right` 边界)
    * **💡 考点 (高频)**：
        * 边界条件 (`while left <= right`) 的精准控制。
        * 变形题：查找**第一个** $\ge$ 目标值的元素。
        * 变形题：查找旋转排序数组。

---
